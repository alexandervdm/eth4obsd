$OpenBSD$

Index: shared/bls/bls.go
--- shared/bls/bls.go.orig
+++ shared/bls/bls.go
@@ -6,96 +6,49 @@ package bls
 import (
 	"github.com/prysmaticlabs/prysm/shared/bls/blst"
 	"github.com/prysmaticlabs/prysm/shared/bls/common"
-	"github.com/prysmaticlabs/prysm/shared/bls/herumi"
-	"github.com/prysmaticlabs/prysm/shared/featureconfig"
 )
 
 // SecretKeyFromBytes creates a BLS private key from a BigEndian byte slice.
 func SecretKeyFromBytes(privKey []byte) (SecretKey, error) {
-	if featureconfig.Get().EnableBlst {
-		return blst.SecretKeyFromBytes(privKey)
-	}
-	return herumi.SecretKeyFromBytes(privKey)
+	return blst.SecretKeyFromBytes(privKey)
 }
 
 // PublicKeyFromBytes creates a BLS public key from a  BigEndian byte slice.
 func PublicKeyFromBytes(pubKey []byte) (PublicKey, error) {
-	if featureconfig.Get().EnableBlst {
-		return blst.PublicKeyFromBytes(pubKey)
-	}
-	return herumi.PublicKeyFromBytes(pubKey)
+	return blst.PublicKeyFromBytes(pubKey)
 }
 
 // SignatureFromBytes creates a BLS signature from a LittleEndian byte slice.
 func SignatureFromBytes(sig []byte) (Signature, error) {
-	if featureconfig.Get().EnableBlst {
-		return blst.SignatureFromBytes(sig)
-	}
-	return herumi.SignatureFromBytes(sig)
+	return blst.SignatureFromBytes(sig)
 }
 
 // AggregatePublicKeys aggregates the provided raw public keys into a single key.
 func AggregatePublicKeys(pubs [][]byte) (PublicKey, error) {
-	if featureconfig.Get().EnableBlst {
-		return blst.AggregatePublicKeys(pubs)
-	}
-	return herumi.AggregatePublicKeys(pubs)
+	return blst.AggregatePublicKeys(pubs)
 }
 
 // AggregateSignatures converts a list of signatures into a single, aggregated sig.
 func AggregateSignatures(sigs []common.Signature) common.Signature {
-	if featureconfig.Get().EnableBlst {
-		return blst.AggregateSignatures(sigs)
-	}
-	return herumi.AggregateSignatures(sigs)
+	return blst.AggregateSignatures(sigs)
 }
 
 // VerifyMultipleSignatures verifies multiple signatures for distinct messages securely.
 func VerifyMultipleSignatures(sigs [][]byte, msgs [][32]byte, pubKeys []common.PublicKey) (bool, error) {
-	if featureconfig.Get().EnableBlst {
-		return blst.VerifyMultipleSignatures(sigs, msgs, pubKeys)
-	}
-	// Manually decompress each signature as herumi does not
-	// have a batch decompress method.
-	rawSigs := make([]Signature, len(sigs))
-	var err error
-	for i, s := range sigs {
-		rawSigs[i], err = herumi.SignatureFromBytes(s)
-		if err != nil {
-			return false, err
-		}
-	}
-	return herumi.VerifyMultipleSignatures(rawSigs, msgs, pubKeys)
+	return blst.VerifyMultipleSignatures(sigs, msgs, pubKeys)
 }
 
 // NewAggregateSignature creates a blank aggregate signature.
 func NewAggregateSignature() common.Signature {
-	if featureconfig.Get().EnableBlst {
-		return blst.NewAggregateSignature()
-	}
-	return herumi.NewAggregateSignature()
+	return blst.NewAggregateSignature()
 }
 
 // RandKey creates a new private key using a random input.
 func RandKey() (common.SecretKey, error) {
-	if featureconfig.Get().EnableBlst {
-		return blst.RandKey()
-	}
-	return herumi.RandKey()
+	return blst.RandKey()
 }
 
 // VerifyCompressed signature.
 func VerifyCompressed(signature, pub, msg []byte) bool {
-	if featureconfig.Get().EnableBlst {
-		return blst.VerifyCompressed(signature, pub, msg)
-	}
-	sig, err := SignatureFromBytes(signature)
-	if err != nil {
-		return false
-	}
-	pk, err := PublicKeyFromBytes(pub)
-	if err != nil {
-		return false
-	}
-	return sig.Verify(pk, msg)
+	return blst.VerifyCompressed(signature, pub, msg)
 }
